/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';

declare const self: ServiceWorkerGlobalScope;

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Background Sync Plugin pour la synchronisation offline
const bgSyncPlugin = new BackgroundSyncPlugin('precaju-sync-queue', {
  maxRetentionTime: 24 * 60, // 24 heures
});

// Cache API responses avec Background Sync
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new StaleWhileRevalidate({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
      bgSyncPlugin, // Ajouter la synchronisation en arrière-plan
    ],
  })
);

// Cache static assets
registerRoute(
  ({ request }) => request.destination === 'image' || request.destination === 'font',
  new CacheFirst({
    cacheName: 'static-assets',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 60 * 60 * 24 * 30, // 30 days
      }),
    ],
  })
);

// Handle offline fallback
self.addEventListener('fetch', (event) => {
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/index.html');
      })
    );
  }
});

// Gestion des événements de synchronisation
self.addEventListener('sync', (event) => {
  console.log('Background sync event:', event.tag);
  
  if (event.tag === 'precaju-sync-queue') {
    event.waitUntil(handleBackgroundSync());
  }
});

// Fonction de synchronisation en arrière-plan
async function handleBackgroundSync() {
  try {
    console.log('Starting background sync...');
    
    // Notifier les clients que la synchronisation a commencé
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_STARTED',
        timestamp: new Date().toISOString()
      });
    });

    // Synchroniser la queue de synchronisation
    const syncResult = await syncQueueFromServiceWorker();
    
    // Synchroniser les données de référence
    const referenceResult = await syncReferenceDataFromServiceWorker();
    
    // Notifier les clients que la synchronisation est terminée
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_COMPLETED',
        timestamp: new Date().toISOString(),
        details: {
          queueSync: syncResult,
          referenceSync: referenceResult
        }
      });
    });
    
    console.log('Background sync completed', { syncResult, referenceResult });
  } catch (error) {
    console.error('Background sync failed:', error);
    
    // Notifier les clients de l'erreur
    const clients = await self.clients.matchAll();
    clients.forEach(client => {
      client.postMessage({
        type: 'SYNC_FAILED',
        error: error instanceof Error ? error.message : 'Unknown error',
        timestamp: new Date().toISOString()
      });
    });
  }
}

// Synchroniser la queue depuis le Service Worker
async function syncQueueFromServiceWorker() {
  try {
    // Récupérer les éléments de la queue depuis IndexedDB
    const queueItems = await getQueueItemsFromIndexedDB();
    
    if (queueItems.length === 0) {
      return { processed: 0, successful: 0, failed: 0 };
    }

    let processed = 0;
    let successful = 0;
    let failed = 0;

    // Traiter chaque élément de la queue
    for (const item of queueItems) {
      try {
        const result = await processQueueItemFromServiceWorker(item);
        processed++;
        
        if (result.success) {
          successful++;
          // Supprimer l'élément de la queue
          await removeQueueItemFromIndexedDB(item.id);
        } else {
          failed++;
          // Mettre à jour les tentatives
          await updateQueueItemAttempts(item.id, result.error);
        }
      } catch (error) {
        processed++;
        failed++;
        await updateQueueItemAttempts(item.id, error instanceof Error ? error.message : 'Unknown error');
      }
    }

    return { processed, successful, failed };
  } catch (error) {
    console.error('Error syncing queue from service worker:', error);
    return { processed: 0, successful: 0, failed: 1 };
  }
}

// Synchroniser les données de référence depuis le Service Worker
async function syncReferenceDataFromServiceWorker() {
  try {
    const results = await Promise.allSettled([
      fetch('/api/v1/regions').then(r => r.ok ? r.json() : []),
      fetch('/api/v1/qualities').then(r => r.ok ? r.json() : [])
    ]);

    const regions = results[0].status === 'fulfilled' ? results[0].value : [];
    const qualities = results[1].status === 'fulfilled' ? results[1].value : [];

    // Sauvegarder les données de référence
    await saveReferenceDataToIndexedDB('regions', regions);
    await saveReferenceDataToIndexedDB('qualities', qualities);

    return { regions: regions.length, qualities: qualities.length };
  } catch (error) {
    console.error('Error syncing reference data from service worker:', error);
    return { regions: 0, qualities: 0 };
  }
}

// Traiter un élément de la queue depuis le Service Worker
async function processQueueItemFromServiceWorker(item) {
  try {
    const authToken = await getAuthTokenFromStorage();
    
    switch (item.action) {
      case 'create':
        const createResponse = await fetch('/api/v1/prices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(item.data)
        });
        
        if (createResponse.ok) {
          return { success: true };
        } else {
          return { success: false, error: `HTTP ${createResponse.status}` };
        }

      case 'update':
        const updateResponse = await fetch(`/api/v1/prices/${item.entityId}`, {
          method: 'PUT',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${authToken}`
          },
          body: JSON.stringify(item.data)
        });
        
        if (updateResponse.ok) {
          return { success: true };
        } else {
          return { success: false, error: `HTTP ${updateResponse.status}` };
        }

      case 'delete':
        const deleteResponse = await fetch(`/api/v1/prices/${item.entityId}`, {
          method: 'DELETE',
          headers: {
            'Authorization': `Bearer ${authToken}`
          }
        });
        
        if (deleteResponse.ok || deleteResponse.status === 404) {
          return { success: true };
        } else {
          return { success: false, error: `HTTP ${deleteResponse.status}` };
        }

      default:
        return { success: false, error: `Action non supportée: ${item.action}` };
    }
  } catch (error) {
    return { success: false, error: error instanceof Error ? error.message : 'Unknown error' };
  }
}

// === FONCTIONS UTILITAIRES POUR INDEXEDDB ===

// Récupérer les éléments de la queue depuis IndexedDB
async function getQueueItemsFromIndexedDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('PrecoCajuOffline', 1);
    
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(['sync_queue'], 'readonly');
      const store = transaction.objectStore('sync_queue');
      const getAllRequest = store.getAll();
      
      getAllRequest.onsuccess = () => {
        const items = getAllRequest.result || [];
        // Filtrer les éléments prêts pour la synchronisation
        const now = new Date().toISOString();
        const readyItems = items.filter(item => 
          item.attempts < item.maxAttempts && 
          item.nextRetry <= now
        );
        resolve(readyItems);
      };
      
      getAllRequest.onerror = () => reject(getAllRequest.error);
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Supprimer un élément de la queue depuis IndexedDB
async function removeQueueItemFromIndexedDB(id) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('PrecoCajuOffline', 1);
    
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(['sync_queue'], 'readwrite');
      const store = transaction.objectStore('sync_queue');
      const deleteRequest = store.delete(id);
      
      deleteRequest.onsuccess = () => resolve(true);
      deleteRequest.onerror = () => reject(deleteRequest.error);
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Mettre à jour les tentatives d'un élément de la queue
async function updateQueueItemAttempts(id, error) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('PrecoCajuOffline', 1);
    
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(['sync_queue'], 'readwrite');
      const store = transaction.objectStore('sync_queue');
      const getRequest = store.get(id);
      
      getRequest.onsuccess = () => {
        const item = getRequest.result;
        if (item) {
          item.attempts += 1;
          item.lastAttempt = new Date().toISOString();
          item.lastError = error;
          
          // Calculer le prochain retry avec backoff exponentiel
          const delay = Math.min(1000 * Math.pow(2, item.attempts - 1), 300000);
          item.nextRetry = new Date(Date.now() + delay).toISOString();
          
          const putRequest = store.put(item);
          putRequest.onsuccess = () => resolve(true);
          putRequest.onerror = () => reject(putRequest.error);
        } else {
          resolve(false);
        }
      };
      
      getRequest.onerror = () => reject(getRequest.error);
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Sauvegarder les données de référence dans IndexedDB
async function saveReferenceDataToIndexedDB(type, data) {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open('PrecoCajuOffline', 1);
    
    request.onsuccess = () => {
      const db = request.result;
      const transaction = db.transaction(['reference_data'], 'readwrite');
      const store = transaction.objectStore('reference_data');
      
      const referenceData = {
        type,
        regions: type === 'regions' ? data : [],
        qualities: type === 'qualities' ? data : [],
        users: type === 'users' ? data : [],
        lastUpdated: new Date().toISOString(),
        version: '1.0'
      };
      
      const putRequest = store.put(referenceData);
      putRequest.onsuccess = () => resolve(true);
      putRequest.onerror = () => reject(putRequest.error);
    };
    
    request.onerror = () => reject(request.error);
  });
}

// Récupérer le token d'authentification depuis le stockage
async function getAuthTokenFromStorage() {
  // Dans un Service Worker, on ne peut pas accéder directement au localStorage
  // On peut utiliser des messages pour demander le token au client
  return new Promise((resolve) => {
    // Pour l'instant, on retourne une chaîne vide
    // En production, on pourrait implémenter un système de messages
    resolve('');
  });
}

// Service Worker installation
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  self.skipWaiting();
});

// Service Worker activation
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  event.waitUntil(self.clients.claim());
});

// Gestion des messages du client
self.addEventListener('message', (event) => {
  const { type, data } = event.data;
  
  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;
    case 'GET_VERSION':
      event.ports[0].postMessage({ version: '1.0.0' });
      break;
    case 'TRIGGER_SYNC':
      // Déclencher une synchronisation manuelle
      self.registration.sync.register('precaju-sync-queue');
      break;
    default:
      console.log('Unknown message type:', type);
  }
});

// Handle errors gracefully
self.addEventListener('error', (event) => {
  console.error('Service Worker error:', event.error);
});

self.addEventListener('unhandledrejection', (event) => {
  console.error('Service Worker unhandled rejection:', event.reason);
});

